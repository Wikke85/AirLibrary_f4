package asfiles.spectrums{	import flash.display.Sprite;	import flash.display.BitmapData;	import flash.utils.ByteArray;	import flash.events.Event;	import flash.display.Shape;	import flash.geom.Point;	import flash.filters.BlurFilter;	import flash.display.Bitmap;	import flash.media.SoundMixer;	import flash.geom.ColorTransform;	import flash.geom.Point;	import flash.events.MouseEvent;	import flash.geom.Matrix;	import flash.errors.EOFError;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	public class SmoothSpectrum extends Sprite	{		// data members		private var nAmp:int;		private var myBytes:ByteArray;		private var myPoints:Array;		private var midPoints:Array;		private var colors:Array;		private var ratios:Array;		private var alphas:Array;		private var matrix:Matrix;		private var blendArray:Array;		private var blendStyle:String;				private var i:int;		private var offset:Number;			private var lng:int;		private var curveLng:int;		private var midPointX:Number;		private var midPointY:Number;		private var mouseDown:Boolean;
						// graphic members		private var myCurve:Shape;		private var myScreen:BitmapData;		private var myPoint:Point;		private var myBlur:BlurFilter;		private var myColorTrans:ColorTransform;		private var displace:Matrix;				public function SmoothSpectrum ( pWidth:Number , pHeight:Number, pAmplitude:int )		{			var myLegende:TextField = new TextField();						myLegende.autoSize = TextFieldAutoSize.LEFT;						myLegende.selectable = false;						myLegende.textColor = 0x777777;						myLegende.text = "bezier computeSpectrum() - bytearray.org";									myLegende.x = 260, myLegende.y = 375;						// our bitmap screen, where the curves are drawn			myScreen = new BitmapData ( pWidth, pHeight, true, 0 );						// default blendMode			blendStyle = 'normal';						// using multiple of 2 increases performance by 40%			myBlur = new BlurFilter ( 2, 2, 2 );						// colorTransformation			myColorTrans = new ColorTransform ();						myColorTrans.color = Math.random()*0xFFFFFF;						// add it to the displayList			addChild ( new Bitmap ( myScreen ) );						addChild ( myLegende );						// byteArray to hold frequencies			myBytes = new ByteArray();						//rotate it				displace = new Matrix();						blendArray = ['layer', 'multiply', 'screen', 'lighten', 'darken',						  'difference', 'add', 'subtract', 'invert', 'alpha', 'erase', 						  'overlay', 'hardlight'];						// points holder			myPoints = new Array();						// midpoints holder			midPoints = new Array();						// set the wavin' amplitude			nAmp = pAmplitude;						// the curve to draw the spectrum			myCurve = new Shape();						// the point			myPoint = new Point ( 0, 0 );						// setup color gradients			colors = [0x990000, 0x00FF00];			alphas = [100, 100];			ratios = [80, 255];			matrix = new Matrix();			matrix.createGradientBox ( 850, 1, 0, 0, 0);						addEventListener (Event.ADDED_TO_STAGE, onAdded);
			addEventListener ( Event.REMOVED, onRemoved );					}				private function onAdded ( pEvt:Event ):void 		{				addEventListener (Event.ENTER_FRAME, updatePoints);								stage.addEventListener (MouseEvent.MOUSE_DOWN, onClick );			}					public function onRemoved( pEvt:Event ):void 		{			myScreen.dispose();						removeEventListener (Event.ENTER_FRAME, updatePoints );						stage.removeEventListener (MouseEvent.MOUSE_DOWN, onClick );		}				private function updatePoints ( pEvt:Event ):void		{			// clear each frame			myCurve.graphics.clear();						myCurve.graphics.lineStyle (.01);						// apply gradient to the line			myCurve.graphics.lineGradientStyle ( 'linear', colors, alphas, ratios, matrix, 'pad', 'linearRGB', 0.1);						// generate the ByteArray			SoundMixer.computeSpectrum ( myBytes, mouseDown );						i = 16;						while ( --i > -1 )			{															// change the position of the pointer				myBytes.position = i * 128;								// get frequency				offset = myBytes.readFloat()*nAmp;
												// push each points 				myPoints[i] = new Point ( int(60 + ( 40 * i )), int(200 + (-offset)) );			}						lng = myPoints.length;						// now generate a mid-point array			// to make those mid-points the curve anchor points			for (var j:int = 1; j< lng; j++ )			{				midPointX = ( myPoints[j].x + myPoints[int(j-1)].x )/2				midPointY = ( myPoints[j].y + myPoints[int(j-1)].y )/2								midPoints[int(j-1)] = new Point (int(midPointX), int(midPointY) );			}						// make the curve start at the first mid-point location			myCurve.graphics.moveTo ( midPoints[0].x, midPoints[0].y );						curveLng = lng-1;						// then draw the curve			for (var k:int = 1; k< curveLng; k++ )				myCurve.graphics.curveTo ( myPoints[k].x, myPoints[k].y, midPoints[k].x, midPoints[k].y );			// scroll the bitmap			myScreen.scroll ( 1, 0 );			// draw curve vectors on the BitmapData			myScreen.draw ( myCurve, null, null, "add" );						myScreen.applyFilter ( myScreen, myScreen.rect, myPoint, myBlur );		}				private function onClick ( pEvt:MouseEvent ):void		{			blendStyle = blendArray [ Math.floor ( Math.random()* blendArray.length ) ];						colors = [Math.random()*0xFFFFFF, Math.random()*0xFFFFFF];						mouseDown = !mouseDown		}	}}